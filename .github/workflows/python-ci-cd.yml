name: Python Complete CI/CD Pipeline

# 触发条件：推送到主要分支、创建PR或手动触发
on:
  push:
    branches: [ main, test ]  # 主分支和测试分支
    paths-ignore:  # 忽略 Markdown/配置文件变更，避免无效触发
      - '**.md'          # 忽略所有 Markdown 文件
      - '.gitignore'     # 忽略 .gitignore 文件
  pull_request:
    branches: [ main, test ]
    paths-ignore:  # 忽略 Markdown/配置文件变更，避免无效触发
      - '**.md'          # 忽略所有 Markdown 文件
      - '.gitignore'     # 忽略 .gitignore 文件
  workflow_dispatch:  # 允许手动触发
      
# 环境变量配置
env:
  # 基础配置
  PROJECT_NAME: "learngit"
  JAVA_VERSION: "11"
  MAVEN_VERSION: "3.9.5"
  # Docker 镜像配置
  REGISTRY: "ghcr.io"
  IMAGE_NAME: "ghcr.io/dqpylf/learngit"
  # 目录配置
  SRC_DIR: "src/main/python"

# 工作流任务
jobs:
  ###########################
  # 1. 准备阶段：代码检出和环境设置
  ###########################
  prepare:
    runs-on: ubuntu-latest
    outputs:
      # 输出Java版本用于后续任务
      java-version: ${{ env.JAVA_VERSION }}
      # 输出当前提交哈希用于版本标识
      commit-hash: ${{ github.sha }}
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 拉取完整历史用于版本号生成

      - name: 设置Java环境
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      - name: 缓存Maven依赖
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: 验证Maven配置
        run: |
          mvn --version
          java -version

  ###########################
  # 2. 代码质量检查 - 暂时注释掉
  ###########################
  # code-quality:
  #   needs: prepare
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: 检出代码
  #       uses: actions/checkout@v4
  #
  #     - name: 恢复Python环境
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: ${{ needs.prepare.outputs.python-version }}
  #
  #     - name: 恢复依赖缓存
  #       uses: actions/cache@v3
  #       with:
  #         path: ~/.cache/pip
  #         key: ${{ runner.os }}-pip-${{ hashFiles(env.REQUIREMENTS_FILE, env.DEV_REQUIREMENTS_FILE) }}
  #
  #     - name: 安装依赖
  #       run: |
  #         pip install -r ${{ env.DEV_REQUIREMENTS_FILE }}
  #
  #     - name: 代码风格检查 (flake8)
  #       run: |
  #         flake8 ${{ env.SRC_DIR }} \
  #           --count \
  #           --exit-zero \
  #           --max-complexity=10 \
  #           --max-line-length=127 \
  #           --statistics
  #         # flake8 ${{ env.SRC_DIR }} ${{ env.TEST_DIR }} \  # 暂时注释掉测试目录检查
  #
  #     - name: 代码格式化检查 (black)
  #       run: |
  #         black --check ${{ env.SRC_DIR }}
  #         # black --check ${{ env.SRC_DIR }} ${{ env.TEST_DIR }}  # 暂时注释掉测试目录检查
  #
  #     - name: 导入顺序检查 (isort)
  #       run: |
  #         isort --check --profile black ${{ env.SRC_DIR }}
  #         # isort --check --profile black ${{ env.SRC_DIR }} ${{ env.TEST_DIR }}  # 暂时注释掉测试目录检查
  #
  #     - name: 静态类型检查 (mypy)
  #       run: |
  #         mypy ${{ env.SRC_DIR }} --ignore-missing-imports
  #
  #     - name: 代码质量评分 (pylint)
  #       run: |
  #         pylint ${{ env.SRC_DIR }} --fail-under=${{ env.LINT_THRESHOLD }}

  ###########################
  # 3. 测试阶段 - 暂时注释掉
  ###########################
  # test:
  #   needs: code-quality
  #   runs-on: ubuntu-latest
  #   strategy:
  #     matrix:
  #       # 测试多个Python版本确保兼容性
  #       python-version: ["3.9", "3.10", "3.11"]
  #       # 测试不同环境配置
  #       environment: ["development", "production"]
  #     fail-fast: false  # 一个版本失败不影响其他版本测试
  #
  #   steps:
  #     - name: 检出代码
  #       uses: actions/checkout@v4
  #
  #     - name: 设置Python ${{ matrix.python-version }}
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: ${{ matrix.python-version }}
  #
  #     - name: 恢复依赖缓存
  #       uses: actions/cache@v3
  #       with:
  #         path: ~/.cache/pip
  #         key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles(env.REQUIREMENTS_FILE) }}
  #
  #     - name: 安装依赖
  #       run: |
  #         pip install -r ${{ env.REQUIREMENTS_FILE }}
  #         pip install -r ${{ env.DEV_REQUIREMENTS_FILE }}
  #
  #     - name: 准备测试报告目录
  #       run: mkdir -p ${{ env.TEST_REPORT_DIR }}
  #
  #     - name: 运行测试 (pytest)
  #       env:
  #         APP_ENV: ${{ matrix.environment }}
  #         TEST_DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
  #       run: |
  #         pytest ${{ env.TEST_DIR }} \
  #           --cov=${{ env.SRC_DIR }} \
  #           --cov-report=xml \
  #           --cov-report=term \
  #           --junitxml=${{ env.TEST_REPORT_DIR }}/results-${{ matrix.python-version }}-${{ matrix.environment }}.xml \
  #           -v
  #
  #     - name: 上传测试报告
  #       uses: actions/upload-artifact@v3
  #       with:
  #         name: test-reports-${{ matrix.python-version }}-${{ matrix.environment }}
  #         path: ${{ env.TEST_REPORT_DIR }}
  #
  #     - name: 上传覆盖率报告到Codecov
  #       uses: codecov/codecov-action@v3
  #       with:
  #         file: ./coverage.xml
  #         flags: unittests
  #         name: codecov-${{ matrix.python-version }}
  #         fail_ci_if_error: true

  ###########################
  # 4. Docker镜像构建阶段
  ###########################
  build:
    needs: prepare  # 直接从准备阶段开始构建（暂时跳过代码质量检查和测试）
    runs-on: ubuntu-latest
    # 只在特定分支构建
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/test'
    outputs:
      version: ${{ steps.version-generator.outputs.version }}
      image-tag: ${{ steps.version-generator.outputs.image-tag }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 需要完整历史来生成版本号

      - name: 设置Java环境
        uses: actions/setup-java@v4
        with:
          java-version: ${{ needs.prepare.outputs.java-version }}
          distribution: 'temurin'

      - name: 恢复Maven依赖缓存
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}

      - name: 生成版本号和镜像标签
        id: version-generator
        run: |
          # 检查是否存在tag
          if git describe --abbrev=0 --tags 2>/dev/null; then
            # 存在tag，使用最近的tag
            LAST_TAG=$(git describe --abbrev=0 --tags)
            HAS_TAG=true
          else
            # 不存在tag，使用默认版本
            LAST_TAG="v0.0.0"
            HAS_TAG=false
          fi
          
          echo "最近的tag: $LAST_TAG (存在真实tag: $HAS_TAG)"
          
          # 提取主版本号
          MAJOR=$(echo $LAST_TAG | cut -d. -f1 | sed 's/v//')
          MINOR=$(echo $LAST_TAG | cut -d. -f2)
          PATCH=$(echo $LAST_TAG | cut -d. -f3)
          
          # 根据分支生成不同的标签
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            # 主分支使用语义版本号
            NEW_PATCH=$((PATCH + 1))
            VERSION="v$MAJOR.$MINOR.$NEW_PATCH"
            IMAGE_TAG="$MAJOR.$MINOR.$NEW_PATCH"
          else
            # 开发分支使用开发版本号
            if [[ "$HAS_TAG" == "true" ]]; then
              COMMIT_COUNT=$(git rev-list --count HEAD ^$LAST_TAG)
            else
              COMMIT_COUNT=$(git rev-list --count HEAD)
            fi
            SHORT_SHA=$(echo "${{ needs.prepare.outputs.commit-hash }}" | cut -c1-8)
            VERSION="$LAST_TAG-dev.$COMMIT_COUNT+$SHORT_SHA"
            IMAGE_TAG="dev-$SHORT_SHA"
          fi
          
          echo "生成版本号: $VERSION"
          echo "生成镜像标签: $IMAGE_TAG"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: 登录到 GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 构建并推送Docker镜像 (使用 Jib)
        run: |
          mvn clean jib:build \
            -Djib.to.image=${{ env.IMAGE_NAME }}:${{ steps.version-generator.outputs.image-tag }}
            
      - name: 推送latest标签 (仅main分支)
        if: github.ref == 'refs/heads/main'
        run: |
          mvn jib:build \
            -Djib.to.image=${{ env.IMAGE_NAME }}:latest

  ###########################
  # 5. 部署阶段 - 生产环境
  ###########################
  deploy-prod:
    needs: [build, prepare]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'  # 只在主分支部署到生产环境
    environment:
      name: production  # 需在GitHub仓库设置中配置保护规则，如手动批准
      url: https://${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.PROJECT_NAME }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        
      - name: 验证生产镜像版本
        run: |
          # 验证版本号格式（语义版本）
          VERSION="${{ needs.build.outputs.version }}"
          if [[ ! $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "错误: 生产版本号格式不正确: $VERSION"
            echo "期望格式: v1.2.3"
            exit 1
          fi
          echo "版本号验证通过: $VERSION"

      - name: 部署到生产服务器
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          IMAGE_TAG: ${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}
        run: |
          # 保存SSH私钥
          echo "$DEPLOY_KEY" > deploy_key
          chmod 600 deploy_key
          
          # 创建部署脚本
          cat > deploy.sh << EOF
          #!/bin/bash
          set -e
          
          # 设置环境变量
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          IMAGE_TAG="${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"
          
          echo "开始部署到生产环境..."
          echo "部署路径: \$DEPLOY_PATH"
          echo "镜像标签: \$IMAGE_TAG"
          
          # 验证必要的环境变量
          if [ -z "\$DEPLOY_PATH" ]; then
              echo "错误: DEPLOY_PATH 环境变量未设置或为空"
              exit 1
          fi
          
          if [ -z "\$IMAGE_TAG" ]; then
              echo "错误: IMAGE_TAG 环境变量未设置"
              exit 1
          fi
          
          # 检查必要的命令是否存在
          command -v docker >/dev/null 2>&1 || { echo "错误: 需要 docker 命令" >&2; exit 1; }
          command -v docker-compose >/dev/null 2>&1 || { echo "错误: 需要 docker-compose 命令" >&2; exit 1; }
          
          # 登录到容器注册表
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          # 创建部署目录
          mkdir -p \$DEPLOY_PATH
          cd \$DEPLOY_PATH
          echo "当前工作目录: \$(pwd)"
          
          # 备份旧版本（如果存在）
          if [ -f docker-compose.yml ]; then
              cp docker-compose.yml docker-compose.yml.backup.\$(date +%Y%m%d_%H%M%S)
              echo "已备份旧配置文件"
          fi
          
          # 停止旧容器（如果存在）
          if [ -f docker-compose.yml ]; then
              docker-compose down || true
          else
              echo "警告: 旧的docker-compose.yml文件不存在，跳过停止容器"
          fi
          
          # 创建生产环境docker-compose.yml文件
          cat > docker-compose.yml << 'COMPOSE_EOF'
          version: '3.8'
          services:
            learngit:
              image: \$IMAGE_TAG
              container_name: learngit-prod
              ports:
                - "5001:5001"
              restart: unless-stopped
              environment:
                - APP_ENV=production
              volumes:
                - ./logs:/app/logs
                - ./config:/app/config
              networks:
                - learngit-network
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:5001/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          
          networks:
            learngit-network:
              driver: bridge
          COMPOSE_EOF
          
          # 替换环境变量
          sed -i "s|\\\$IMAGE_TAG|\$IMAGE_TAG|g" docker-compose.yml
          
          echo "Docker Compose配置文件:"
          cat docker-compose.yml
          
          # 创建必要的目录
          mkdir -p logs config
          
          # 拉取最新镜像
          echo "拉取最新镜像: \$IMAGE_TAG"
          docker-compose pull
          
          # 启动新容器
          echo "启动生产环境容器..."
          docker-compose up -d
          
          # 等待容器启动
          echo "等待容器启动..."
          sleep 15
          
          # 健康检查
          echo "执行健康检查..."
          MAX_RETRIES=12
          RETRY_COUNT=0
          
          while [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; do
              if docker-compose ps | grep -q "Up"; then
                  echo "生产环境部署成功！"
                  docker-compose ps
                  docker-compose logs --tail=20
                  break
              else
                  RETRY_COUNT=\$((RETRY_COUNT + 1))
                  echo "健康检查失败，重试 \$RETRY_COUNT/\$MAX_RETRIES ..."
                  sleep 10
              fi
              
              if [ \$RETRY_COUNT -eq \$MAX_RETRIES ]; then
                  echo "部署失败，执行回滚..."
                  docker-compose ps
                  docker-compose logs
                  
                  # 回滚到备份版本
                  if [ -f docker-compose.yml.backup.* ]; then
                      BACKUP_FILE=\$(ls -t docker-compose.yml.backup.* | head -1)
                      echo "回滚到备份文件: \$BACKUP_FILE"
                      cp "\$BACKUP_FILE" docker-compose.yml
                      docker-compose down || true
                      docker-compose up -d || true
                  fi
                  
                  exit 1
              fi
          done
          
          # 清理旧镜像（保留最近2个版本）
          echo "清理旧镜像..."
          docker image prune -f
          
          echo "生产环境部署完成！"
          
          EOF
          
          # 上传部署脚本并执行
          scp -i deploy_key -o StrictHostKeyChecking=no deploy.sh $DEPLOY_USER@$DEPLOY_HOST:~/deploy.sh
          ssh -i deploy_key -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_HOST "bash ~/deploy.sh && rm ~/deploy.sh"
          
          # 清理临时文件
          rm deploy_key deploy.sh

      - name: 创建GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.build.outputs.version }}
          name: Release ${{ needs.build.outputs.version }}
          body: |
            **新版本发布**: ${{ needs.build.outputs.version }}
            
            ## Docker 镜像
            
            ```bash
            # 拉取镜像
            docker pull ${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}
            docker pull ${{ env.IMAGE_NAME }}:latest
            
            # 运行容器
            docker run -p 5001:5001 ${{ env.IMAGE_NAME }}:latest
            ```
            
            ## 变更内容
            
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  ###########################
  # 6. 部署阶段 - 测试环境
  ###########################
  deploy-test:
    needs: [build, prepare]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/test'  # 只在测试分支部署到测试环境
    environment:
      name: staging
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        
      - name: 部署到测试服务器
        env:
          DEPLOY_HOST: ${{ secrets.TEST_DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.TEST_DEPLOY_USER }}
          DEPLOY_KEY: ${{ secrets.TEST_DEPLOY_KEY }}
          DEPLOY_PATH: ${{ secrets.TEST_DEPLOY_PATH }}
          IMAGE_TAG: ${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}
        run: |
          # 保存SSH私钥
          echo "$DEPLOY_KEY" > deploy_key
          chmod 600 deploy_key
          
          # 创建部署脚本
          cat > deploy.sh << EOF
          #!/bin/bash
          set -e
          
          # 设置环境变量
          DEPLOY_PATH="${{ secrets.TEST_DEPLOY_PATH }}"
          IMAGE_TAG="${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image-tag }}"
          
          echo "开始部署到测试环境..."
          echo "部署路径: \$DEPLOY_PATH"
          echo "镜像标签: \$IMAGE_TAG"
          
          # 验证必要的环境变量
          if [ -z "\$DEPLOY_PATH" ]; then
              echo "错误: TEST_DEPLOY_PATH 环境变量未设置或为空"
              exit 1
          fi
          
          if [ -z "\$IMAGE_TAG" ]; then
              echo "错误: IMAGE_TAG 环境变量未设置"
              exit 1
          fi
          
          # 检查必要的命令是否存在
          command -v docker >/dev/null 2>&1 || { echo "错误: 需要 docker 命令" >&2; exit 1; }
          command -v docker-compose >/dev/null 2>&1 || { echo "错误: 需要 docker-compose 命令" >&2; exit 1; }
          
          # 登录到容器注册表
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          # 创建部署目录
          mkdir -p \$DEPLOY_PATH
          cd \$DEPLOY_PATH
          echo "当前工作目录: \$(pwd)"
          
          # 停止旧容器（如果存在）
          if [ -f docker-compose.yml ]; then
              docker-compose down || true
          else
              echo "警告: 旧的docker-compose.yml文件不存在，跳过停止容器"
          fi
          
          # 创建测试环境docker-compose.yml文件
          cat > docker-compose.yml << 'COMPOSE_EOF'
          version: '3.8'
          services:
            learngit:
              image: \$IMAGE_TAG
              container_name: learngit-test
              ports:
                - "5002:5001"
              restart: unless-stopped
              environment:
                - APP_ENV=testing
              volumes:
                - ./logs:/app/logs
                - ./config:/app/config
              networks:
                - learngit-test-network
          
          networks:
            learngit-test-network:
              driver: bridge
          COMPOSE_EOF
          
          # 替换环境变量
          sed -i "s|\\\$IMAGE_TAG|\$IMAGE_TAG|g" docker-compose.yml
          
          echo "Docker Compose配置文件:"
          cat docker-compose.yml
          
          # 创建必要的目录
          mkdir -p logs config
          
          # 拉取最新镜像
          echo "拉取最新镜像: \$IMAGE_TAG"
          docker-compose pull
          
          # 启动新容器
          echo "启动测试环境容器..."
          docker-compose up -d
          
          # 等待容器启动
          echo "等待容器启动..."
          sleep 10
          
          # 健康检查
          if docker-compose ps | grep -q "Up"; then
              echo "测试环境部署成功！"
              docker-compose ps
              docker-compose logs --tail=10
          else
              echo "部署失败，查看容器状态:"
              docker-compose ps
              docker-compose logs
              exit 1
          fi
          
          # 清理旧镜像
          docker image prune -f
          
          echo "测试环境部署完成！"
          
          EOF
          
          # 上传部署脚本并执行
          scp -i deploy_key -o StrictHostKeyChecking=no deploy.sh $DEPLOY_USER@$DEPLOY_HOST:~/deploy.sh
          ssh -i deploy_key -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_HOST "bash ~/deploy.sh && rm ~/deploy.sh"
          
          # 清理临时文件
          rm deploy_key deploy.sh
