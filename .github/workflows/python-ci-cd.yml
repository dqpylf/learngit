name: Python Docker CI/CD Pipeline (Maven + Jib)

# 触发条件：推送到主要分支、创建PR或手动触发
on:
  push:
    branches: [ main, int ]  # 主分支和int分支
    paths-ignore:  # 忽略 Markdown/配置文件变更，避免无效触发
      - '**.md'          # 忽略所有 Markdown 文件
      - '.gitignore'     # 忽略 .gitignore 文件
  pull_request:
    branches: [ main, int ]
    paths-ignore:  # 忽略 Markdown/配置文件变更，避免无效触发
      - '**.md'          # 忽略所有 Markdown 文件
      - '.gitignore'     # 忽略 .gitignore 文件
  workflow_dispatch:  # 允许手动触发

permissions:
  contents: read
  packages: write
      
# 环境变量配置
env:
  # 基础配置
  PROJECT_NAME: "learngit"
  JAVA_VERSION: "11"
  MAVEN_VERSION: "3.9.5"
  # Docker 镜像配置
  REGISTRY: "ghcr.io"
  IMAGE_NAME: "ghcr.io/dqpylf/learngit"
  # 目录配置
  SRC_DIR: "src/main/python"

# 工作流任务
jobs:
  ###########################
  # 1. 准备阶段：代码检出和环境设置
  ###########################
  prepare:
    runs-on: ubuntu-latest
    outputs:
      # 输出Java版本用于后续任务
      java-version: ${{ env.JAVA_VERSION }}
      # 输出当前提交哈希用于版本标识
      commit-hash: ${{ github.sha }}
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 拉取完整历史用于版本号生成

      - name: 设置Java环境
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      - name: 缓存Maven依赖
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: 验证Maven配置
        run: |
          mvn --version
          java -version

  ###########################
  # 2. 代码质量检查 - 暂时注释掉
  ###########################
  # code-quality:
  #   needs: prepare
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: 检出代码
  #       uses: actions/checkout@v4
  #
  #     - name: 恢复Python环境
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: ${{ needs.prepare.outputs.python-version }}
  #
  #     - name: 恢复依赖缓存
  #       uses: actions/cache@v3
  #       with:
  #         path: ~/.cache/pip
  #         key: ${{ runner.os }}-pip-${{ hashFiles(env.REQUIREMENTS_FILE, env.DEV_REQUIREMENTS_FILE) }}
  #
  #     - name: 安装依赖
  #       run: |
  #         pip install -r ${{ env.DEV_REQUIREMENTS_FILE }}
  #
  #     - name: 代码风格检查 (flake8)
  #       run: |
  #         flake8 ${{ env.SRC_DIR }} \
  #           --count \
  #           --exit-zero \
  #           --max-complexity=10 \
  #           --max-line-length=127 \
  #           --statistics
  #         # flake8 ${{ env.SRC_DIR }} ${{ env.TEST_DIR }} \  # 暂时注释掉测试目录检查
  #
  #     - name: 代码格式化检查 (black)
  #       run: |
  #         black --check ${{ env.SRC_DIR }}
  #         # black --check ${{ env.SRC_DIR }} ${{ env.TEST_DIR }}  # 暂时注释掉测试目录检查
  #
  #     - name: 导入顺序检查 (isort)
  #       run: |
  #         isort --check --profile black ${{ env.SRC_DIR }}
  #         # isort --check --profile black ${{ env.SRC_DIR }} ${{ env.TEST_DIR }}  # 暂时注释掉测试目录检查
  #
  #     - name: 静态类型检查 (mypy)
  #       run: |
  #         mypy ${{ env.SRC_DIR }} --ignore-missing-imports
  #
  #     - name: 代码质量评分 (pylint)
  #       run: |
  #         pylint ${{ env.SRC_DIR }} --fail-under=${{ env.LINT_THRESHOLD }}

  ###########################
  # 3. 测试阶段 - 暂时注释掉
  ###########################
  # test:
  #   needs: code-quality
  #   runs-on: ubuntu-latest
  #   strategy:
  #     matrix:
  #       # 测试多个Python版本确保兼容性
  #       python-version: ["3.9", "3.10", "3.11"]
  #       # 测试不同环境配置
  #       environment: ["development", "production"]
  #     fail-fast: false  # 一个版本失败不影响其他版本测试
  #
  #   steps:
  #     - name: 检出代码
  #       uses: actions/checkout@v4
  #
  #     - name: 设置Python ${{ matrix.python-version }}
  #       uses: actions/setup-python@v5
  #       with:
  #         python-version: ${{ matrix.python-version }}
  #
  #     - name: 恢复依赖缓存
  #       uses: actions/cache@v3
  #       with:
  #         path: ~/.cache/pip
  #         key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles(env.REQUIREMENTS_FILE) }}
  #
  #     - name: 安装依赖
  #       run: |
  #         pip install -r ${{ env.REQUIREMENTS_FILE }}
  #         pip install -r ${{ env.DEV_REQUIREMENTS_FILE }}
  #
  #     - name: 准备测试报告目录
  #       run: mkdir -p ${{ env.TEST_REPORT_DIR }}
  #
  #     - name: 运行测试 (pytest)
  #       env:
  #         APP_ENV: ${{ matrix.environment }}
  #         TEST_DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
  #       run: |
  #         pytest ${{ env.TEST_DIR }} \
  #           --cov=${{ env.SRC_DIR }} \
  #           --cov-report=xml \
  #           --cov-report=term \
  #           --junitxml=${{ env.TEST_REPORT_DIR }}/results-${{ matrix.python-version }}-${{ matrix.environment }}.xml \
  #           -v
  #
  #     - name: 上传测试报告
  #       uses: actions/upload-artifact@v3
  #       with:
  #         name: test-reports-${{ matrix.python-version }}-${{ matrix.environment }}
  #         path: ${{ env.TEST_REPORT_DIR }}
  #
  #     - name: 上传覆盖率报告到Codecov
  #       uses: codecov/codecov-action@v3
  #       with:
  #         file: ./coverage.xml
  #         flags: unittests
  #         name: codecov-${{ matrix.python-version }}
  #         fail_ci_if_error: true

  ###########################
  # 4. Docker镜像构建阶段
  ###########################
  build:
    needs: prepare  # 直接从准备阶段开始构建（暂时跳过代码质量检查和测试）
    runs-on: ubuntu-latest
    # 只在特定分支构建
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/int'
    outputs:
      image-tag: ${{ github.sha }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置Java环境
        uses: actions/setup-java@v4
        with:
          java-version: ${{ needs.prepare.outputs.java-version }}
          distribution: 'temurin'

      - name: 恢复Maven依赖缓存
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}



      - name: 登录到 GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 构建并推送Docker镜像 (使用 Jib)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "开始构建镜像: ${{ env.IMAGE_NAME }}:${{ github.sha }}"
          echo "认证信息: ${{ github.actor }}"
          
          # 使用与ci-cd.yml相同的简洁配置
          mvn jib:build \
            -Dimage=${{ env.IMAGE_NAME }}:${{ github.sha }} \
            -DskipTests=true
          
          echo "镜像构建完成: ${{ env.IMAGE_NAME }}:${{ github.sha }}"

      - name: 推送latest标签 (仅main分支)
        if: github.ref == 'refs/heads/main'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "推送latest标签..."
          mvn jib:build \
            -Dimage=${{ env.IMAGE_NAME }}:latest \
            -DskipTests=true

  ###########################
  # 5. 部署阶段 - 生产环境
  ###########################
  deploy-prod:
    needs: [build, prepare]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: production  # 需在GitHub仓库设置中配置保护规则，如手动批准
      url: https://${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.PROJECT_NAME }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        


      - name: 部署到生产服务器
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          IMAGE_TAG: ${{ env.IMAGE_NAME }}:${{ github.sha }}
        run: |
          # 保存SSH私钥
          echo "$DEPLOY_KEY" > deploy_key
          chmod 600 deploy_key
          
          # 创建部署脚本
          cat > deploy.sh << EOF
          #!/bin/bash
          set -e
          
          # 设置环境变量
          DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
          IMAGE_TAG="${{ env.IMAGE_NAME }}:${{ github.sha }}"
          
          echo "开始部署到生产环境..."
          echo "部署路径: \$DEPLOY_PATH"
          echo "镜像标签: \$IMAGE_TAG"
          
          # 验证必要的环境变量
          if [ -z "\$DEPLOY_PATH" ]; then
              echo "错误: DEPLOY_PATH 环境变量未设置或为空"
              exit 1
          fi
          
          if [ -z "\$IMAGE_TAG" ]; then
              echo "错误: IMAGE_TAG 环境变量未设置"
              exit 1
          fi
          
          # 检查必要的命令是否存在
          command -v docker >/dev/null 2>&1 || { echo "错误: 需要 docker 命令" >&2; exit 1; }
          command -v docker-compose >/dev/null 2>&1 || { echo "错误: 需要 docker-compose 命令" >&2; exit 1; }
          
          # 登录到容器注册表
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          # 创建部署目录
          mkdir -p \$DEPLOY_PATH
          cd \$DEPLOY_PATH
          echo "当前工作目录: \$(pwd)"
          
          # 备份旧版本（如果存在）
          if [ -f docker-compose.yml ]; then
              cp docker-compose.yml docker-compose.yml.backup.\$(date +%Y%m%d_%H%M%S)
              echo "已备份旧配置文件"
          fi
          
          # 停止旧容器（如果存在）
          if [ -f docker-compose.yml ]; then
              docker-compose down || true
          else
              echo "警告: 旧的docker-compose.yml文件不存在，跳过停止容器"
          fi
          
          # 下载生产环境配置文件
          echo "正在下载生产环境配置文件..."
          
          # 使用 GitHub API 下载文件 (支持私有仓库)
          DOWNLOAD_SUCCESS=false
          
          # 从main分支下载生产环境配置文件
          if curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3.raw" \
                  -o docker-compose.prod.yml \
                  "https://api.github.com/repos/${{ github.repository_owner }}/${{ env.PROJECT_NAME }}/contents/deploy/docker-compose.prod.yml?ref=main"; then
              echo "从main分支下载成功"
              DOWNLOAD_SUCCESS=true
          else
              echo "从main分支下载失败"
              DOWNLOAD_SUCCESS=false
          fi
          
          # 验证文件下载是否成功
          if [ "\$DOWNLOAD_SUCCESS" = false ] || [ ! -s docker-compose.prod.yml ]; then
              echo "错误: docker-compose.prod.yml 下载失败或为空"
              echo "尝试显示下载的内容:"
              cat docker-compose.prod.yml 2>/dev/null || echo "无法读取文件内容"
              echo "当前目录内容:"
              ls -la
              exit 1
          fi
          
          echo "生产环境配置文件下载成功"
          echo "文件大小: \$(wc -c < docker-compose.prod.yml) 字节"
          echo "文件前几行内容:"
          head -5 docker-compose.prod.yml
          
          # 重命名为标准的 docker-compose.yml
          mv docker-compose.prod.yml docker-compose.yml
          echo "已重命名为 docker-compose.yml"
          
          # 更新镜像标签
          echo "更新镜像标签: \$IMAGE_TAG"
          # 显示替换前的内容
          echo "替换前的镜像配置:"
          grep -n "image:" docker-compose.yml || echo "未找到image配置"
          
          # 使用更精确的sed命令替换镜像标签
          sed -i "s|image: ghcr.io/dqpylf/learngit:.*|image: \$IMAGE_TAG|g" docker-compose.yml
          
          # 显示替换后的内容
          echo "替换后的镜像配置:"
          grep -n "image:" docker-compose.yml || echo "未找到image配置"
          
          # 创建必要的目录
          mkdir -p logs config
          
          # 拉取最新镜像
          echo "拉取最新镜像: \$IMAGE_TAG"
          docker-compose pull
          
          # 启动新容器
          echo "启动生产环境容器..."
          docker-compose up -d
          
          # 等待容器启动
          echo "等待容器启动..."
          sleep 15
          
          # 健康检查
          echo "执行健康检查..."
          MAX_RETRIES=12
          RETRY_COUNT=0
          
          while [ \$RETRY_COUNT -lt \$MAX_RETRIES ]; do
              if docker-compose ps | grep -q "Up"; then
                  echo "生产环境部署成功！"
                  docker-compose ps
                  docker-compose logs --tail=20
                  break
              else
                  RETRY_COUNT=\$((RETRY_COUNT + 1))
                  echo "健康检查失败，重试 \$RETRY_COUNT/\$MAX_RETRIES ..."
                  sleep 10
              fi
              
              if [ \$RETRY_COUNT -eq \$MAX_RETRIES ]; then
                  echo "部署失败，执行回滚..."
                  docker-compose ps
                  docker-compose logs
                  
                  # 回滚到备份版本
                  if [ -f docker-compose.yml.backup.* ]; then
                      BACKUP_FILE=\$(ls -t docker-compose.yml.backup.* | head -1)
                      echo "回滚到备份文件: \$BACKUP_FILE"
                      cp "\$BACKUP_FILE" docker-compose.yml
                      docker-compose down || true
                      docker-compose up -d || true
                  fi
                  
                  exit 1
              fi
          done
          
          # 清理旧镜像（保留最近2个版本）
          echo "清理旧镜像..."
          docker image prune -f
          
          echo "生产环境部署完成！"
          
          EOF
          
          # 上传部署脚本并执行
          scp -i deploy_key -o StrictHostKeyChecking=no deploy.sh $DEPLOY_USER@$DEPLOY_HOST:~/deploy.sh
          ssh -i deploy_key -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_HOST "bash ~/deploy.sh && rm ~/deploy.sh"
          
          # 清理临时文件
          rm deploy_key deploy.sh

      - name: 创建GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.sha }}
          name: Release ${{ github.sha }}
          body: |
            **新版本发布**: ${{ github.sha }}
            
            ## Docker 镜像
            
            ```bash
            # 拉取镜像
            docker pull ${{ env.IMAGE_NAME }}:${{ github.sha }}
            docker pull ${{ env.IMAGE_NAME }}:latest
            
            # 运行容器
            docker run -p 5001:5001 ${{ env.IMAGE_NAME }}:latest
            ```
            
            ## 变更内容
            
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  ###########################
  # 6. 部署阶段 - 测试环境
  ###########################
  deploy-test:
    needs: [build, prepare]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/int'
    environment:
      name: staging
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        
      - name: 部署到测试服务器
        env:
          DEPLOY_HOST: ${{ secrets.TEST_DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.TEST_DEPLOY_USER }}
          DEPLOY_KEY: ${{ secrets.TEST_DEPLOY_KEY }}
          DEPLOY_PATH: ${{ secrets.TEST_DEPLOY_PATH }}
          IMAGE_TAG: ${{ env.IMAGE_NAME }}:${{ github.sha }}
        run: |
          # 保存SSH私钥
          echo "$DEPLOY_KEY" > deploy_key
          chmod 600 deploy_key
          
          # 创建部署脚本
          cat > deploy.sh << EOF
          #!/bin/bash
          set -e
          
          # 设置环境变量
          DEPLOY_PATH="${{ secrets.TEST_DEPLOY_PATH }}"
          IMAGE_TAG="${{ env.IMAGE_NAME }}:${{ github.sha }}"
          
          echo "开始部署到测试环境..."
          echo "部署路径: \$DEPLOY_PATH"
          echo "镜像标签: \$IMAGE_TAG"
          
          # 验证必要的环境变量
          if [ -z "\$DEPLOY_PATH" ]; then
              echo "错误: TEST_DEPLOY_PATH 环境变量未设置或为空"
              exit 1
          fi
          
          if [ -z "\$IMAGE_TAG" ]; then
              echo "错误: IMAGE_TAG 环境变量未设置"
              exit 1
          fi
          
          # 检查必要的命令是否存在
          command -v docker >/dev/null 2>&1 || { echo "错误: 需要 docker 命令" >&2; exit 1; }
          command -v docker-compose >/dev/null 2>&1 || { echo "错误: 需要 docker-compose 命令" >&2; exit 1; }
          
          # 登录到容器注册表
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          # 创建部署目录
          mkdir -p \$DEPLOY_PATH
          cd \$DEPLOY_PATH
          echo "当前工作目录: \$(pwd)"
          
          # 停止旧容器（如果存在）
          if [ -f docker-compose.yml ]; then
              docker-compose down || true
          else
              echo "警告: 旧的docker-compose.yml文件不存在，跳过停止容器"
          fi
          
          # 下载测试环境配置文件
          echo "正在下载测试环境配置文件..."
          
          # 使用 GitHub API 下载文件 (支持私有仓库)
          DOWNLOAD_SUCCESS=false
          
          # 从int分支下载测试环境配置文件
          if curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3.raw" \
                  -o docker-compose.test.yml \
                  "https://api.github.com/repos/${{ github.repository_owner }}/${{ env.PROJECT_NAME }}/contents/deploy/docker-compose.test.yml?ref=int"; then
              echo "从int分支下载成功"
              DOWNLOAD_SUCCESS=true
          else
              echo "从int分支下载失败"
              DOWNLOAD_SUCCESS=false
          fi
          
          # 验证文件下载是否成功
          if [ "\$DOWNLOAD_SUCCESS" = false ] || [ ! -s docker-compose.test.yml ]; then
              echo "错误: docker-compose.test.yml 下载失败或为空"
              echo "尝试显示下载的内容:"
              cat docker-compose.test.yml 2>/dev/null || echo "无法读取文件内容"
              echo "当前目录内容:"
              ls -la
              exit 1
          fi
          
          echo "测试环境配置文件下载成功"
          echo "文件大小: \$(wc -c < docker-compose.test.yml) 字节"
          echo "文件前几行内容:"
          head -5 docker-compose.test.yml
          
          # 重命名为标准的 docker-compose.yml
          mv docker-compose.test.yml docker-compose.yml
          echo "已重命名为 docker-compose.yml"
          
          # 更新镜像标签
          echo "更新镜像标签: \$IMAGE_TAG"
          # 显示替换前的内容
          echo "替换前的镜像配置:"
          grep -n "image:" docker-compose.yml || echo "未找到image配置"
          
          # 使用sed命令替换镜像标签
          sed -i "s|image: ghcr.io/dqpylf/learngit:.*|image: \$IMAGE_TAG|g" docker-compose.yml
          
          # 显示替换后的内容
          echo "替换后的镜像配置:"
          grep -n "image:" docker-compose.yml || echo "未找到image配置"
          
          # 创建必要的目录
          mkdir -p logs config
          
          # 拉取最新镜像
          echo "拉取最新镜像: \$IMAGE_TAG"
          docker-compose pull
          
          # 启动新容器
          echo "启动测试环境容器..."
          docker-compose up -d
          
          # 等待容器启动
          echo "等待容器启动..."
          sleep 10
          
          # 健康检查
          if docker-compose ps | grep -q "Up"; then
              echo "测试环境部署成功！"
              docker-compose ps
              docker-compose logs --tail=10
          else
              echo "部署失败，查看容器状态:"
              docker-compose ps
              docker-compose logs
              exit 1
          fi
          
          # 清理旧镜像
          docker image prune -f
          
          echo "测试环境部署完成！"
          
          EOF
          
          # 上传部署脚本并执行
          scp -i deploy_key -o StrictHostKeyChecking=no deploy.sh $DEPLOY_USER@$DEPLOY_HOST:~/deploy.sh
          ssh -i deploy_key -o StrictHostKeyChecking=no $DEPLOY_USER@$DEPLOY_HOST "bash ~/deploy.sh && rm ~/deploy.sh"
          
          # 清理临时文件
          rm deploy_key deploy.sh
